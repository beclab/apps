{{- if and .Values.admin .Values.bfl.username (eq .Values.admin .Values.bfl.username) }}

---
# Redis extension ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: dify-redis-extension
  namespace: {{ .Release.Namespace }}
  labels:
    app: dify
    component: api
data:
  ext_redis.py: |
    from typing import Any, Union

    import socket
    import redis
    from redis.cluster import ClusterNode, RedisCluster
    from redis.connection import Connection, SSLConnection
    from redis.sentinel import Sentinel

    from configs import dify_config
    from dify_app import DifyApp


    class RedisClientWrapper:
        """
        A wrapper class for the Redis client that addresses the issue where the global
        `redis_client` variable cannot be updated when a new Redis instance is returned
        by Sentinel.

        This class allows for deferred initialization of the Redis client, enabling the
        client to be re-initialized with a new instance when necessary. This is particularly
        useful in scenarios where the Redis instance may change dynamically, such as during
        a failover in a Sentinel-managed Redis setup.

        Attributes:
            _client (redis.Redis): The actual Redis client instance. It remains None until
                                  initialized with the `initialize` method.

        Methods:
            initialize(client): Initializes the Redis client if it hasn't been initialized already.
            __getattr__(item): Delegates attribute access to the Redis client, raising an error
                              if the client is not initialized.
        """

        def __init__(self):
            self._client = None

        def initialize(self, client):
            if self._client is None:
                self._client = client

        def __getattr__(self, item):
            if self._client is None:
                raise RuntimeError("Redis client is not initialized. Call init_app first.")
            return getattr(self._client, item)


    redis_client = RedisClientWrapper()


    def init_app(app: DifyApp):
        global redis_client
        connection_class: type[Union[Connection, SSLConnection]] = Connection
        if dify_config.REDIS_USE_SSL:
            connection_class = SSLConnection

        redis_params: dict[str, Any] = {
            "username": dify_config.REDIS_USERNAME,
            "password": dify_config.REDIS_PASSWORD or None,  # Temporary fix for empty password
            "db": dify_config.REDIS_DB,
            "encoding": "utf-8",
            "encoding_errors": "strict",
            "decode_responses": False,
        }
        
        # Add connection pool configuration parameters
        pool_params: dict[str, Any] = {
            "max_connections": getattr(dify_config, "REDIS_MAX_CONNECTIONS", 10),  # Default to 10 if not specified
            # "min_connections": getattr(dify_config, "REDIS_MIN_CONNECTIONS", 1),   # Default to 1 if not specified
            "socket_timeout": getattr(dify_config, "REDIS_SOCKET_TIMEOUT", None),
            "socket_connect_timeout": getattr(dify_config, "REDIS_SOCKET_CONNECT_TIMEOUT", None),
            "socket_keepalive": getattr(dify_config, "REDIS_SOCKET_KEEPALIVE", None),
            "health_check_interval": getattr(dify_config, "REDIS_HEALTH_CHECK_INTERVAL", 30),
        }
        
        # Filter out None values to use Redis client defaults
        pool_params = {k: v for k, v in pool_params.items() if v is not None}

        if dify_config.REDIS_USE_SENTINEL:
            assert dify_config.REDIS_SENTINELS is not None, "REDIS_SENTINELS must be set when REDIS_USE_SENTINEL is True"
            sentinel_hosts = [
                (node.split(":")[0], int(node.split(":")[1])) for node in dify_config.REDIS_SENTINELS.split(",")
            ]
            sentinel = Sentinel(
                sentinel_hosts,
                sentinel_kwargs={
                    "socket_timeout": dify_config.REDIS_SENTINEL_SOCKET_TIMEOUT,
                    "username": dify_config.REDIS_SENTINEL_USERNAME,
                    "password": dify_config.REDIS_SENTINEL_PASSWORD,
                },
            )
            master = sentinel.master_for(dify_config.REDIS_SENTINEL_SERVICE_NAME, **redis_params)
            redis_client.initialize(master)
        elif dify_config.REDIS_USE_CLUSTERS:
            assert dify_config.REDIS_CLUSTERS is not None, "REDIS_CLUSTERS must be set when REDIS_USE_CLUSTERS is True"
            nodes = [
                ClusterNode(host=node.split(":")[0], port=int(node.split(":")[1]))
                for node in dify_config.REDIS_CLUSTERS.split(",")
            ]
            # FIXME: mypy error here, try to figure out how to fix it
            redis_client.initialize(RedisCluster(startup_nodes=nodes, password=dify_config.REDIS_CLUSTERS_PASSWORD))  # type: ignore
        else:
            redis_params.update(
                {
                    "host": dify_config.REDIS_HOST,
                    "port": dify_config.REDIS_PORT,
                    "connection_class": connection_class,
                }
            )
            # Create pool with the pool parameters
            pool = redis.ConnectionPool(
              host=dify_config.REDIS_HOST,
              port=dify_config.REDIS_PORT,
              connection_class=connection_class,
              socket_keepalive=True,
              username=dify_config.REDIS_USERNAME,
              password=dify_config.REDIS_PASSWORD or None,  
              db=dify_config.REDIS_DB,
              encoding="utf-8",
              encoding_errors="strict",
              decode_responses=False,
              
              socket_keepalive_options={
                  socket.TCP_KEEPIDLE: 60,
                  socket.TCP_KEEPINTVL: 10,
                  socket.TCP_KEEPCNT: 3,
              })
            redis_client.initialize(redis.Redis(connection_pool=pool))

        app.extensions["redis"] = redis_client


---
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    kompose.cmd: kompose convert
    kompose.version: 1.35.0 (HEAD)
  labels:
    io.kompose.service: api
  name: api
  namespace: {{ .Release.Namespace }}
spec:
  replicas: 1
  selector:
    matchLabels:
      io.kompose.service: api
  strategy:
    type: Recreate
  template:
    metadata:
      annotations:
        kompose.cmd: kompose convert
        kompose.version: "1.35.0 (HEAD)"
      labels:
        io.kompose.service: api
    spec:
      initContainers:
        - name: init-chmod-data
          image: "docker.io/beclab/aboveos-busybox:1.37.0"
          # busybox runs as root by default so can chown
          command:
            - sh
            - -c
            - |
              set -eux
              # ensure the directory exists then fix ownership
              mkdir -p /app/api/storage
              chown -R 1001:1001 /app/api/storage
          resources: {}
          volumeMounts:
            - name: api-vol
              mountPath: /app/api/storage
          securityContext:
            runAsUser: 0
      containers:
        - name: api
          image: "docker.io/beclab/dify-api:1.11.1"
          envFrom:
            - configMapRef:
                name: dify-api-env
          env:
            - name: DB_EXTRAS
              value: "keepalives=1&keepalives_idle=30&keepalives_interval=10&keepalives_count=3"
          ports:
            - containerPort: 5001
              name: http
          resources:
            requests:
              cpu: 500m
              memory: 1Gi
            limits:
              cpu: "1"
              memory: 2Gi
          volumeMounts:
            - mountPath: /app/api/storage
              name: api-vol
      restartPolicy: Always
      volumes:
        - name: api-vol
          hostPath:
            type: DirectoryOrCreate
            path: {{ .Values.userspace.appCache }}/volumes/app/storage
{{- end }}
